{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":true,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SASjs Server Documentation \u00b6 SASjs Server provides a visual interface and REST API for executing programs directly against the SAS executable ( sas.exe / sas.sh ). The executable could be on a desktop, or an actual SAS server. It works in a broadly similar way to the SAS\u00ae Stored Process server, or the Viya Job Execution Service - if you have either of these, then it is likely you do not need SASjs Server. SASjs Server is FAST - responsiveness (for SAS Stored Programs) is around 200 milliseconds. The following features are provided out of the box: SASjs Studio - for running SAS code and examining webout content REST API - documentation which can also used to make actual API calls AppStream - a portal for home-grown or third-party SAS-Powered Web Applications If you are running older versions of SAS, or SAS on a desktop, then this product will enable you to: Install third party apps (such as Data Controller for SAS ) Run tests on your SAS Jobs, Services and Macros Execute SAS code from a browser Execute JS code from SAS Build applications on SAS SASjs Server is MIT open source and the repository is available here: https://github.com/sasjs/server .","title":"Home"},{"location":"#sasjs-server-documentation","text":"SASjs Server provides a visual interface and REST API for executing programs directly against the SAS executable ( sas.exe / sas.sh ). The executable could be on a desktop, or an actual SAS server. It works in a broadly similar way to the SAS\u00ae Stored Process server, or the Viya Job Execution Service - if you have either of these, then it is likely you do not need SASjs Server. SASjs Server is FAST - responsiveness (for SAS Stored Programs) is around 200 milliseconds. The following features are provided out of the box: SASjs Studio - for running SAS code and examining webout content REST API - documentation which can also used to make actual API calls AppStream - a portal for home-grown or third-party SAS-Powered Web Applications If you are running older versions of SAS, or SAS on a desktop, then this product will enable you to: Install third party apps (such as Data Controller for SAS ) Run tests on your SAS Jobs, Services and Macros Execute SAS code from a browser Execute JS code from SAS Build applications on SAS SASjs Server is MIT open source and the repository is available here: https://github.com/sasjs/server .","title":"SASjs Server Documentation"},{"location":"apps/","text":"App Stream \u00b6 AppStream is the gateway to apps on SASjs Server. Creating Apps \u00b6 Anybody can create an app for SASjs Server - it just needs to be compiled using the SASjs CLI . The output of this process is a zip file that can be imported to any SASjs Server instance. Deploying Apps \u00b6 Simply click the \"Upload New App\" button and select the local zip file containing the app you wish to deploy. Alternative deployment approaches include: sasjs deploy - https://cli.sasjs.io/deploy/ Use the /SASjsApi/drive/deploy/upload API Use the /SASjsApi/drive/deploy API Securing Apps \u00b6 If you are running in \"Server\" mode you can grant permissions at the level of User or Group to any uploaded application - just click on your username, then \"Settings\", then \"Permissions\", to create the necessary rule(s). Available Apps \u00b6 SASjs Server does not have an in-built \"app store\" (due to our security policy of having no external web requests), however you may download apps yourself from the following locations and upload them to your SASjs Server instance. Productivity Apps \u00b6 Data Controller for SAS\u00ae \u00b6 Data Controller is a full-blown SAS application to provide business users with a carefully-controlled capability to make changes to data in SAS. The app can be downloaded from here: https://git.4gl.io/dc/deploy/raw/branch/main/server.json.zip . Documentation is here: https://docs.datacontroller.io . Seed Apps \u00b6 The following apps are presented as \"starter packs\" with which you can build your own SASjs App: Angular Seed App \u00b6 A demo app built using Angular. Builds are published to the releases page . Minimal Seed App \u00b6 This is a simple demo app built with Vanilla JS and SAS. You can find the latest version on the github releases page React Seed App \u00b6 The primary template used by the SAS Apps team . Artefacts available on the releases page. Games \u00b6 The serious part of the game series is that you can see how easy it is to deploy generic web apps to SASjs Server - or any SAS server for that matter! Mario \u00b6 Needs no introduction. Release assets available here: https://github.com/sasjs/mario/releases Pacman \u00b6 Another video game classic! Release assets are available here: https://github.com/sasjs/pacman/releases Rock Roller \u00b6 Dodge the trees and move down the slope! Release assets are available here: https://github.com/sasjs/rockroller/releases .","title":"App Stream"},{"location":"apps/#app-stream","text":"AppStream is the gateway to apps on SASjs Server.","title":"App Stream"},{"location":"apps/#creating-apps","text":"Anybody can create an app for SASjs Server - it just needs to be compiled using the SASjs CLI . The output of this process is a zip file that can be imported to any SASjs Server instance.","title":"Creating Apps"},{"location":"apps/#deploying-apps","text":"Simply click the \"Upload New App\" button and select the local zip file containing the app you wish to deploy. Alternative deployment approaches include: sasjs deploy - https://cli.sasjs.io/deploy/ Use the /SASjsApi/drive/deploy/upload API Use the /SASjsApi/drive/deploy API","title":"Deploying Apps"},{"location":"apps/#securing-apps","text":"If you are running in \"Server\" mode you can grant permissions at the level of User or Group to any uploaded application - just click on your username, then \"Settings\", then \"Permissions\", to create the necessary rule(s).","title":"Securing Apps"},{"location":"apps/#available-apps","text":"SASjs Server does not have an in-built \"app store\" (due to our security policy of having no external web requests), however you may download apps yourself from the following locations and upload them to your SASjs Server instance.","title":"Available Apps"},{"location":"apps/#productivity-apps","text":"","title":"Productivity Apps"},{"location":"apps/#data-controller-for-sas","text":"Data Controller is a full-blown SAS application to provide business users with a carefully-controlled capability to make changes to data in SAS. The app can be downloaded from here: https://git.4gl.io/dc/deploy/raw/branch/main/server.json.zip . Documentation is here: https://docs.datacontroller.io .","title":"Data Controller for SAS\u00ae"},{"location":"apps/#seed-apps","text":"The following apps are presented as \"starter packs\" with which you can build your own SASjs App:","title":"Seed Apps"},{"location":"apps/#angular-seed-app","text":"A demo app built using Angular. Builds are published to the releases page .","title":"Angular Seed App"},{"location":"apps/#minimal-seed-app","text":"This is a simple demo app built with Vanilla JS and SAS. You can find the latest version on the github releases page","title":"Minimal Seed App"},{"location":"apps/#react-seed-app","text":"The primary template used by the SAS Apps team . Artefacts available on the releases page.","title":"React Seed App"},{"location":"apps/#games","text":"The serious part of the game series is that you can see how easy it is to deploy generic web apps to SASjs Server - or any SAS server for that matter!","title":"Games"},{"location":"apps/#mario","text":"Needs no introduction. Release assets available here: https://github.com/sasjs/mario/releases","title":"Mario"},{"location":"apps/#pacman","text":"Another video game classic! Release assets are available here: https://github.com/sasjs/pacman/releases","title":"Pacman"},{"location":"apps/#rock-roller","text":"Dodge the trees and move down the slope! Release assets are available here: https://github.com/sasjs/rockroller/releases .","title":"Rock Roller"},{"location":"auth/","text":"Authentication \u00b6 SASjs Server currently supports two authentication methods - LDAP, and Internal. Would you like to see more? Sponsor us! Note that authentication is only available in server mode (not desktop). Internal Authentication \u00b6 By default, users are created using the internal database with a password configured by an admin. Groups can also be added, and permissions set against those groups. LDAP Authentication \u00b6 SASjs Server can connect to an LDAP server (internally, we use the LDAPjs library). Any users / groups that are imported will be in addition to any internal users / groups. If there are conflicts, those particular users/groups will not be imported - to fix this, just delete the relevant (SASjs internal) users/groups and re-import. Note that at least one internal admin user is necessary, to be able to log in and do the import. After this, the internal user may nominate other (LDAP) users as SASjs admins. Configuration is made in the following .env settings: AUTH_PROVIDERS=ldap LDAP_URL= ldaps://LDAP_SERVER_URL:PORT LDAP_BIND_DN= cn=admin,ou=system,dc=companyname LDAP_BIND_PASSWORD = <password> LDAP_USERS_BASE_DN = ou=users,dc=companyname LDAP_GROUPS_BASE_DN = ou=groups,dc=companyname Next, restart the server and log in with the admin user. Navigate to the settings tab. You should see a screen like the below. Import the users & groups by clicking the 'synchronise' button. Brute Force Protection \u00b6 SASjs Server now protects authentication endpoints from DDoS and brute force attacks at any scale. We adopted a simple and powerful technique to block authorization attempts using two metrics: The first is number of consecutive failed attempts by the same user name and IP address. The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day. To achieve above metrics we used an npm package rate-limiter-flexible . This technique has following configurable env variables: # After this, access is blocked for 1 day # default: 100 MAX_WRONG_ATTEMPTS_BY_IP_PER_DAY = <number> # After this, access is blocked for an hour # Store number for 90 days since first fail # Once a successful login is attempted, it resets # Default: 10 MAX_CONSECUTIVE_FAILS_BY_USERNAME_AND_IP = <number> Admin Account \u00b6 The default credentials for login are secretuser and secretpassword . These can be adjusted using the ADMIN_USERNAME and ADMIN_PASSWORD_INITIAL options on server startup. If the admin password is misplaced, it can be reset by restarting the server with ADMIN_PASSWORD_RESET set to YES . Be sure to set it back to NO (or remove the option) to prevent the password being reset on any subsequent server restart.","title":"Authentication"},{"location":"auth/#authentication","text":"SASjs Server currently supports two authentication methods - LDAP, and Internal. Would you like to see more? Sponsor us! Note that authentication is only available in server mode (not desktop).","title":"Authentication"},{"location":"auth/#internal-authentication","text":"By default, users are created using the internal database with a password configured by an admin. Groups can also be added, and permissions set against those groups.","title":"Internal Authentication"},{"location":"auth/#ldap-authentication","text":"SASjs Server can connect to an LDAP server (internally, we use the LDAPjs library). Any users / groups that are imported will be in addition to any internal users / groups. If there are conflicts, those particular users/groups will not be imported - to fix this, just delete the relevant (SASjs internal) users/groups and re-import. Note that at least one internal admin user is necessary, to be able to log in and do the import. After this, the internal user may nominate other (LDAP) users as SASjs admins. Configuration is made in the following .env settings: AUTH_PROVIDERS=ldap LDAP_URL= ldaps://LDAP_SERVER_URL:PORT LDAP_BIND_DN= cn=admin,ou=system,dc=companyname LDAP_BIND_PASSWORD = <password> LDAP_USERS_BASE_DN = ou=users,dc=companyname LDAP_GROUPS_BASE_DN = ou=groups,dc=companyname Next, restart the server and log in with the admin user. Navigate to the settings tab. You should see a screen like the below. Import the users & groups by clicking the 'synchronise' button.","title":"LDAP Authentication"},{"location":"auth/#brute-force-protection","text":"SASjs Server now protects authentication endpoints from DDoS and brute force attacks at any scale. We adopted a simple and powerful technique to block authorization attempts using two metrics: The first is number of consecutive failed attempts by the same user name and IP address. The second is number of failed attempts from an IP address over some long period of time. For example, block an IP address if it makes 100 failed attempts in one day. To achieve above metrics we used an npm package rate-limiter-flexible . This technique has following configurable env variables: # After this, access is blocked for 1 day # default: 100 MAX_WRONG_ATTEMPTS_BY_IP_PER_DAY = <number> # After this, access is blocked for an hour # Store number for 90 days since first fail # Once a successful login is attempted, it resets # Default: 10 MAX_CONSECUTIVE_FAILS_BY_USERNAME_AND_IP = <number>","title":"Brute Force Protection"},{"location":"auth/#admin-account","text":"The default credentials for login are secretuser and secretpassword . These can be adjusted using the ADMIN_USERNAME and ADMIN_PASSWORD_INITIAL options on server startup. If the admin password is misplaced, it can be reset by restarting the server with ADMIN_PASSWORD_RESET set to YES . Be sure to set it back to NO (or remove the option) to prevent the password being reset on any subsequent server restart.","title":"Admin Account"},{"location":"faq/","text":"FAQ \u00b6 Where can I learn more? \u00b6 The following resources may be helpful: Deploying SASjs Server on a VPS Load Balancing with SASjs Youtube playlist Github: https://github.com/sasjs/server RawSAS blog site Do I need a server? \u00b6 No! You can run SASjs Server on your laptop or computer - so long as you have a local instance of SAS. Will this work on SAS Viya? \u00b6 Yes - you can point to the sas.sh in the SPRE folder Will this work on SAS EBI? \u00b6 Yes - just point to the sas executable in the SASHOME folder Will this work with SAS University Edition \u00b6 No. If you are running University Edition, or the free / online learning instance, you cannot use SASjs. This is because there is no connectivity outside of these environments.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#where-can-i-learn-more","text":"The following resources may be helpful: Deploying SASjs Server on a VPS Load Balancing with SASjs Youtube playlist Github: https://github.com/sasjs/server RawSAS blog site","title":"Where can I learn more?"},{"location":"faq/#do-i-need-a-server","text":"No! You can run SASjs Server on your laptop or computer - so long as you have a local instance of SAS.","title":"Do I need a server?"},{"location":"faq/#will-this-work-on-sas-viya","text":"Yes - you can point to the sas.sh in the SPRE folder","title":"Will this work on SAS Viya?"},{"location":"faq/#will-this-work-on-sas-ebi","text":"Yes - just point to the sas executable in the SASHOME folder","title":"Will this work on SAS EBI?"},{"location":"faq/#will-this-work-with-sas-university-edition","text":"No. If you are running University Edition, or the free / online learning instance, you cannot use SASjs. This is because there is no connectivity outside of these environments.","title":"Will this work with SAS University Edition"},{"location":"installation/","text":"Installation \u00b6 The latest version can be downloaded from the Releases page: https://github.com/sasjs/server/releases It can also be installed in just two lines of code (on linux): curl -L https://github.com/sasjs/server/releases/latest/download/linux.zip > linux.zip unzip linux.zip For windows, just download the zip file and launch. You can ignore / cancel the popup, the app does NOT require administrative privileges. Configuration \u00b6 After installation, there is only one mandatory input: SAS_PATH -> the full path to the SAS executable (eg /path/to/sas.exe|sh ) in your environment. However there are many additional settings you can make - these can go in a file called .env in the same folder as the unzipped SASjs Server executable (eg api-linux / api-win.exe ). Simply create the file with sample contents such as below: SAS_PATH = /path/to/your/sas.sh # This part enables multi-user SAS (optional) MODE = server DB_CONNECT = mongodb+srv://admin:admin@cluster.mongodb.net/mydb?retryWrites = true & w = majority # This part enables TLS (also optional) PROTOCOL = https CERT_CHAIN = /opt/certificates/fullchain.pem PRIVATE_KEY = /opt/certificates/privkey.pem PORT = 443 Then launch the executable (eg ./api-win.exe or double click). If launching from terminal there should be a link in the log to open the app (eg http://localhost:5000). If double clicking, the browser should open automatically. A full guide to deploying SASjs Server on a Ubuntu VPS is available here . SSL Certificates \u00b6 To run over https , SASjs server needs a copy of your certificates. The path to these certificates should be provided in the PRIVATE_KEY and CERT_CHAIN settings. If you are using self-signed certificates, then the CA_ROOT file should also be provided. Example config: PROTOCOL=https CERT_CHAIN=/opt/certificates/fullchain.pem PRIVATE_KEY=/opt/certificates/privkey.pem Suggested instructions for obtaining certificates on a linux environment are provided below. sudo snap install core ; sudo snap refresh core sudo snap install --classic certbot sudo ln -s /snap/bin/certbot /usr/bin/certbot # provide domain to prompt below WITHOUT https prefix, eg your.domain.com sudo certbot certonly --standalone # check for certificates sudo ls /etc/letsencrypt/live/your.domain.com For debugging certificate issues, the following link is useful: https://certbot.eff.org/instructions?ws=other&os=ubuntufocal","title":"Installation"},{"location":"installation/#installation","text":"The latest version can be downloaded from the Releases page: https://github.com/sasjs/server/releases It can also be installed in just two lines of code (on linux): curl -L https://github.com/sasjs/server/releases/latest/download/linux.zip > linux.zip unzip linux.zip For windows, just download the zip file and launch. You can ignore / cancel the popup, the app does NOT require administrative privileges.","title":"Installation"},{"location":"installation/#configuration","text":"After installation, there is only one mandatory input: SAS_PATH -> the full path to the SAS executable (eg /path/to/sas.exe|sh ) in your environment. However there are many additional settings you can make - these can go in a file called .env in the same folder as the unzipped SASjs Server executable (eg api-linux / api-win.exe ). Simply create the file with sample contents such as below: SAS_PATH = /path/to/your/sas.sh # This part enables multi-user SAS (optional) MODE = server DB_CONNECT = mongodb+srv://admin:admin@cluster.mongodb.net/mydb?retryWrites = true & w = majority # This part enables TLS (also optional) PROTOCOL = https CERT_CHAIN = /opt/certificates/fullchain.pem PRIVATE_KEY = /opt/certificates/privkey.pem PORT = 443 Then launch the executable (eg ./api-win.exe or double click). If launching from terminal there should be a link in the log to open the app (eg http://localhost:5000). If double clicking, the browser should open automatically. A full guide to deploying SASjs Server on a Ubuntu VPS is available here .","title":"Configuration"},{"location":"installation/#ssl-certificates","text":"To run over https , SASjs server needs a copy of your certificates. The path to these certificates should be provided in the PRIVATE_KEY and CERT_CHAIN settings. If you are using self-signed certificates, then the CA_ROOT file should also be provided. Example config: PROTOCOL=https CERT_CHAIN=/opt/certificates/fullchain.pem PRIVATE_KEY=/opt/certificates/privkey.pem Suggested instructions for obtaining certificates on a linux environment are provided below. sudo snap install core ; sudo snap refresh core sudo snap install --classic certbot sudo ln -s /snap/bin/certbot /usr/bin/certbot # provide domain to prompt below WITHOUT https prefix, eg your.domain.com sudo certbot certonly --standalone # check for certificates sudo ls /etc/letsencrypt/live/your.domain.com For debugging certificate issues, the following link is useful: https://certbot.eff.org/instructions?ws=other&os=ubuntufocal","title":"SSL Certificates"},{"location":"permissions/","text":"Permissions \u00b6 Permissions in SASjs are enabled when MODE=server . Rules do not apply to admin users. The menu is available under SETTINGS, and is divided into \"URI Access\" and \"Folder Access\". Rules can be at GROUP or USER level. The hierarchy of rules is as follows: By default, deny all Apply group grants Apply group deny Apply user grants Apply user deny URI Access \u00b6 URI rules can be applied to the following endpoints: /AppStream /SASjsApi/code/execute /SASjsApi/stp/execute /SASjsApi/drive/deploy /SASjsApi/drive/deploy/upload /SASjsApi/drive/file /SASjsApi/drive/folder /SASjsApi/drive/fileTree /SASjsApi/permission They can also be applied to individual apps. This part of the list is dynamically generated, for example: /AppStream/DataController /AppStream/Mario /AppStream/Sonic Folder Access \u00b6 Coming soon. Need it sooner? Sponsor us !","title":"Authorisation"},{"location":"permissions/#permissions","text":"Permissions in SASjs are enabled when MODE=server . Rules do not apply to admin users. The menu is available under SETTINGS, and is divided into \"URI Access\" and \"Folder Access\". Rules can be at GROUP or USER level. The hierarchy of rules is as follows: By default, deny all Apply group grants Apply group deny Apply user grants Apply user deny","title":"Permissions"},{"location":"permissions/#uri-access","text":"URI rules can be applied to the following endpoints: /AppStream /SASjsApi/code/execute /SASjsApi/stp/execute /SASjsApi/drive/deploy /SASjsApi/drive/deploy/upload /SASjsApi/drive/file /SASjsApi/drive/folder /SASjsApi/drive/fileTree /SASjsApi/permission They can also be applied to individual apps. This part of the list is dynamically generated, for example: /AppStream/DataController /AppStream/Mario /AppStream/Sonic","title":"URI Access"},{"location":"permissions/#folder-access","text":"Coming soon. Need it sooner? Sponsor us !","title":"Folder Access"},{"location":"roadmap/","text":"Roadmap \u00b6 Authentication \u00b6 The below are simply notes, in relation to the potential for additional authentication options for SASjs Server. Regardless of the mechanism used, credentials and user attributes are encrypted and stored internally as a JWT token. The token is associated with a SASjs Session ID, which is passed in each API request inside an Authorisation: header attribute OR a cookie. Viya Auth \u00b6 This approach is recommended whenever Viya authorisation is available. The configuration steps are as follows: Configure SASjs Server for Viya Auth Register a client and secret (administrator task) using the authorization_code grant type. Here are some helpful resources . Enter the client / secret into the SASjs database (tool to be provided) The user flow is as follows: Navigate to {SASjsServerUrl}/SASjsLogon Click \"LOGON\" Behind the scenes, the following flow will occur: /SASjsLogon page will request the CLIENT_ID from /SASjsApi/auth/viyaclientid (unsecured endpoint) The user is redirected to /SASLogon/oauth/authorize?response_type=code&client_id=${CLIENT_ID} Following authentication, the frontend will pass the AUTH_CODE to backend Backend will send CLIENT_ID, CLIENT_SECRET and AUTH_CODE to /SASLogon/oauth/token , receiving the ACCESS_TOKEN and REFRESH_TOKEN in response The ACCESS_TOKEN and REFRESH_TOKEN are stored (securely) in a JWT, and associated with a SASjs SESSION_ID The SESSION_ID is returned to /SASjsLogon and stored in a cookie Subsequent requests by the Frontend, or API clients, will make use of the SASjs Session ID (until expiry). If the ACCESS_TOKEN expires, the backend will refresh it automatically using the REFRESH_TOKEN. The following diagram illustrates: Auth0 \u00b6 Auth0 is a third party authentication provider, which supports all major authentication methods - such as SAML, SSO, LDAP, Social Logins, etc etc.","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"","title":"Roadmap"},{"location":"roadmap/#authentication","text":"The below are simply notes, in relation to the potential for additional authentication options for SASjs Server. Regardless of the mechanism used, credentials and user attributes are encrypted and stored internally as a JWT token. The token is associated with a SASjs Session ID, which is passed in each API request inside an Authorisation: header attribute OR a cookie.","title":"Authentication"},{"location":"roadmap/#viya-auth","text":"This approach is recommended whenever Viya authorisation is available. The configuration steps are as follows: Configure SASjs Server for Viya Auth Register a client and secret (administrator task) using the authorization_code grant type. Here are some helpful resources . Enter the client / secret into the SASjs database (tool to be provided) The user flow is as follows: Navigate to {SASjsServerUrl}/SASjsLogon Click \"LOGON\" Behind the scenes, the following flow will occur: /SASjsLogon page will request the CLIENT_ID from /SASjsApi/auth/viyaclientid (unsecured endpoint) The user is redirected to /SASLogon/oauth/authorize?response_type=code&client_id=${CLIENT_ID} Following authentication, the frontend will pass the AUTH_CODE to backend Backend will send CLIENT_ID, CLIENT_SECRET and AUTH_CODE to /SASLogon/oauth/token , receiving the ACCESS_TOKEN and REFRESH_TOKEN in response The ACCESS_TOKEN and REFRESH_TOKEN are stored (securely) in a JWT, and associated with a SASjs SESSION_ID The SESSION_ID is returned to /SASjsLogon and stored in a cookie Subsequent requests by the Frontend, or API clients, will make use of the SASjs Session ID (until expiry). If the ACCESS_TOKEN expires, the backend will refresh it automatically using the REFRESH_TOKEN. The following diagram illustrates:","title":"Viya Auth"},{"location":"roadmap/#auth0","text":"Auth0 is a third party authentication provider, which supports all major authentication methods - such as SAML, SSO, LDAP, Social Logins, etc etc.","title":"Auth0"},{"location":"sessions/","text":"Sessions \u00b6 A session occurs in a session folder, and may be executed using either a SAS or a JS runtime. The session folder will contain any uploaded files, as well as the program / script being executed (prepended with code to enable relevant variables, such as URL parameters). The program itself will write the output to _webout , setting the header properties in a file, the location of which is in the sasjs_stpsrv_header_loc variable. SAS Runtime \u00b6 In triggering the SAS executable, there are two factors that need to be overcome: The process is expensive to launch (startup cost) Once launched, the process will run until the end and cannot be 'communicated' with directly To improve responsiveness, it is critical to prelaunch SAS sessions. But how to provide an arbitrary SAS program to a running SAS session (without impacting the session itself)? The solution, was to take the following steps: Launch SAS with an autoexec and a dummy program (SAS won't start without SYSIN) Delete the dummy file in the autoexec, then loop until the \"real\" program appears The actual SAS code used for this: data _null_ ; /* remove the dummy SYSIN */ length fname $ 8 ; rc= filename (fname, getoption( 'SYSIN' ) ); if rc= 0 and fexist( fname) then rc= fdelete( fname); rc= filename (fname); /* now wait for the real SYSIN */ slept= 0 ; do until ( fileexist(getoption( 'SYSIN' )) or slept>( 60 * 15 ) ); /* check every 100ms if the file exists yet */ slept=slept+sleep( 0.1 , 1 ); end ; run; With this loop in place, SASjs Server can prespawn a SAS session and wait until a request arrives. It will then perform the following in parallel: Spawn a new session (ready for the next request) Inject the _PROGRAM code into an existing (HOT) session This is a simplistic overview. In reality it's a bit more complicated as we need to create a unique folder for each session, keep track of the sessions, and ensure we don't launch a session that is just about to expire. We also need to work across multiple threads. The full process flow is therefore as follows: JS Runtime \u00b6 JS sessions are not pre-spawned, as NodeJS is already running. URL variables are injected into the beginning of the program as constants.","title":"Sessions"},{"location":"sessions/#sessions","text":"A session occurs in a session folder, and may be executed using either a SAS or a JS runtime. The session folder will contain any uploaded files, as well as the program / script being executed (prepended with code to enable relevant variables, such as URL parameters). The program itself will write the output to _webout , setting the header properties in a file, the location of which is in the sasjs_stpsrv_header_loc variable.","title":"Sessions"},{"location":"sessions/#sas-runtime","text":"In triggering the SAS executable, there are two factors that need to be overcome: The process is expensive to launch (startup cost) Once launched, the process will run until the end and cannot be 'communicated' with directly To improve responsiveness, it is critical to prelaunch SAS sessions. But how to provide an arbitrary SAS program to a running SAS session (without impacting the session itself)? The solution, was to take the following steps: Launch SAS with an autoexec and a dummy program (SAS won't start without SYSIN) Delete the dummy file in the autoexec, then loop until the \"real\" program appears The actual SAS code used for this: data _null_ ; /* remove the dummy SYSIN */ length fname $ 8 ; rc= filename (fname, getoption( 'SYSIN' ) ); if rc= 0 and fexist( fname) then rc= fdelete( fname); rc= filename (fname); /* now wait for the real SYSIN */ slept= 0 ; do until ( fileexist(getoption( 'SYSIN' )) or slept>( 60 * 15 ) ); /* check every 100ms if the file exists yet */ slept=slept+sleep( 0.1 , 1 ); end ; run; With this loop in place, SASjs Server can prespawn a SAS session and wait until a request arrives. It will then perform the following in parallel: Spawn a new session (ready for the next request) Inject the _PROGRAM code into an existing (HOT) session This is a simplistic overview. In reality it's a bit more complicated as we need to create a unique folder for each session, keep track of the sessions, and ensure we don't launch a session that is just about to expire. We also need to work across multiple threads. The full process flow is therefore as follows:","title":"SAS Runtime"},{"location":"sessions/#js-runtime","text":"JS sessions are not pre-spawned, as NodeJS is already running. URL variables are injected into the beginning of the program as constants.","title":"JS Runtime"},{"location":"settings/","text":"Settings \u00b6 All settings in SASjs server are made by means of environment variables. These can be set in the following places: Configured globally in /etc/environment file Export in terminal or shell script (export VAR=VALUE) Prepended in the command Enter in the .env file alongside the executable The usual / preferred method is to provide the variables in the .env file (which works on both Windows & Linux) as follows: In a server environment, it is highly recommended to protect this file with appropriate permissions (eg, to prevent changes being made by the shared identity under which the server is launched) Environment Variables \u00b6 ADMIN_PASSWORD_INITIAL \u00b6 Defines the initial (temporary) password for the ADMIN_USERNAME , which is in place until the first login. Default is secretpassword . Example: ADMIN_PASSWORD_INITIAL=secretpassword ADMIN_PASSWORD_RESET \u00b6 This option can be used to force a reset of the password of the ADMIN_USERNAME . Default is NO. Possible options are YES and NO. If ADMIN_PASSWORD_RESET=YES then the ADMIN_USERNAME will be prompted to change the password from ADMIN_PASSWORD_INITIAL (default is secretpassword ) on next login. This will repeat on every server restart, unless the option is removed / set to NO. If the ADMIN_USERNAME is an existing, non-admin user then the password will NOT be reset (only works for admins). If the ADMIN_USERNAME uses an auth provider (eg LDAP) then again, this approach will not work. In this case, you can create a new admin user by setting a new ADMIN_USERNAME. Example: ADMIN_PASSWORD_RESET=NO ADMIN_USERNAME \u00b6 Used to define the name of the admin user on server startup. The default value is secretuser . If the user does not exist, it is created (eg during restarts). Example: ADMIN_USERNAME=secretuser AUTH_PROVIDERS \u00b6 Used to list the desired Authentication providers (space separated). Currently only LDAP ( ldap ) is supported, but we plan to allow other providers such as Viya, Okta, OpenID, and LNURL-auth. Example: AUTH_PROVIDERS=ldap ALLOWED_DOMAIN \u00b6 Prevent authentication from other domains by listing the primary domain here. This will reject cookies arriving from any other domain. Used only when MODE=server , and only relevant for SASjs Studio / SASjs Logon. Example: ALLOWED_DOMAIN=sas.company.com For API use by different servers / domains, see CORS and WHITELIST settings. CERT_CHAIN \u00b6 Necessary when PROTOCOL=https Example: CERT_CHAIN=localhost.crt See also: PROTOCOL CA_ROOT PRIVATE_KEY Developer notes: processed internally as cert: option which has this description: Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private key, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see ca). When providing multiple cert chains, they do not have to be in the same order as their private keys in key. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail. CA_ROOT \u00b6 Necessary when PROTOCOL=https AND the server uses a self-signed certificate. Example: CA_ROOT=fullchain.pem See also: PROTOCOL CA_ROOT PRIVATE_KEY Developer notes: processed internally as ca: option which has this description: Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option. The value can be a string or Buffer, or an Array of strings and/or Buffers. Any string or Buffer can contain multiple PEM CAs concatenated together. The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated. When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain to one of the default CAs, use the ca option to provide a CA certificate that the peer's certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided. For PEM encoded certificates, supported types are \"TRUSTED CERTIFICATE\", \"X509 CERTIFICATE\", and \"CERTIFICATE\". See also tls.rootCertificates. CORS \u00b6 Options: [disable|enable] Default: disable for server & enable for desktop If enabled, it is also necessary to configure the WHITELIST of additional server(s). DB_CONNECT \u00b6 In server mode it is necessary to use a database to store a number of attributes, such as: Users & Groups (if not using LDAP or other authentication source) Clients / Secrets (to enable REST API connections) Private keys (to spawn client ids, session tokens etc) Permissions (which users / groups are authorised to access which resources) This value contains the Connection string for the DB instance. Example: DB_CONNECT=mongodb+srv://<DB_USERNAME>:<DB_PASSWORD>@<CLUSTER>/<DB_NAME>?retryWrites=true&w=majority See also: DB_TYPE DB_TYPE \u00b6 Specify the type of database. When DB_TYPE=cosmos_mongodb the connection is made using compatibility mode . Options: [mongodb|cosmos_mongodb] Default: mongodb DRIVE_LOCATION \u00b6 This setting is useful if you are running multiple instances of SASjs Server and would like to re-use the same Drive folder, Macros, Packages, and appStream config. The DRIVE_LOCATION can be shared across instances, but the SASJS_ROOT can't - as it will cause conflicts with sessions / uploads etc. If using this feature, be aware that the appStreamConfig.json is loaded on server startup - therefore if you are deploying a new app (or modifying app metadata attributes, such as the logo), the other instances will need to be restarted to view them in the portal. If this is problematic for your project, please raise an issue . See also: LOG_LOCATION SASJS_ROOT HELMET_COEP \u00b6 HELMET Cross Origin Embedder Policy. Sets the Cross-Origin-Embedder-Policy header to require-corp when true Options: [true|false] Default: true Docs: https://helmetjs.github.io/#reference ( crossOriginEmbedderPolicy ) HELMET_CSP_CONFIG_PATH \u00b6 HELMET Content Security Policy Path to a json file containing HELMET contentSecurityPolicy directives Docs: https://helmetjs.github.io/#reference Example config: { \"img-src\": [\"'self'\", \"data:\"], \"script-src\": [\"'self'\", \"'unsafe-inline'\"], \"script-src-attr\": [\"'self'\", \"'unsafe-inline'\"] } Example: HELMET_CSP_CONFIG_PATH=./csp.config.json LDAP_URL \u00b6 The URL of the LDAP directory server. Example: LDAP_URL= ldaps://LDAP_SERVER_URL:PORT LDAP_BIND_DN \u00b6 Example: LDAP_BIND_DN=cn=admin,ou=system,dc=companyname LDAP_BIND_PASSWORD \u00b6 All LDAP queries have to be authenticated with this secret and the LDAP_USERS_BASE_DN Example: LDAP_BIND_PASSWORD = <password> LDAP_USERS_BASE_DN \u00b6 LDAP_USERS_BASE_DN = ou=users,dc=companyname LDAP_GROUPS_BASE_DN \u00b6 LDAP_GROUPS_BASE_DN = ou=groups,dc=companyname LOG_FORMAT_MORGAN \u00b6 These setting determines the level of logging produced by SASjs server. More details on this can be found in the Morgan documentation here: https://www.npmjs.com/package/morgan#predefined-formats Options: [ combined | common | dev | short | tiny ] Default: common LOG_LOCATION \u00b6 Location in which to write server logs (one file per day). If not provided, logs are written in a /logs subfolder of the SASJS_ROOT location. Can be a full path, else relative to the directory in which the server instance was launched. More information on the behaviour (eg log rotation) is available in the underlying package ( rotating-file-stream ). Example: LOG_LOCATION=./sasjs_root/logs MOCK_SERVERTYPE \u00b6 Used internally for CLI / Adapter testing - set to SAS9 or SASVIYA when launching to enable responses in the format of alternative platforms. These mocks are not functional, and have no use outside of development / testing purposes. Default: SASJS MODE \u00b6 Whether to launch the server in desktop (single user / workstation) or server mode (multi-user). For server mode, a Mongo DB connection string must be provided in the DB_CONNECT variable. Default: desktop NODE_PATH \u00b6 The path to the NodeJS executable (for running JavaScript programs). Example: NODE_PATH=~/.nvm/versions/node/v16.14.0/bin/node See also: PYTHON_PATH RUN_TIMES SAS_PATH PORT \u00b6 The port on which to serve. Default: 5000 Binding processes to ports in the lower ranges (eg 80, 443) requires elevated privileges. To avoid running SASjs Server under a privileged account, you can bind the port to an executable - eg: setcap 'cap_net_bind_service=+ep' /home/sasjssrv/api-linux If the executable is updated (eg downloading a new version) you will need to run this command again. PRIVATE_KEY \u00b6 Necessary when PROTOCOL=https Example: PRIVATE_KEY=localhost.key See also: PROTOCOL CA_ROOT CERT_CHAIN Developer notes: processed internally as key: option which has this description: Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.passphrase. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form {pem: [, passphrase: ]}. The object form can only occur in an array. object.passphrase is optional. Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not. PROTOCOL \u00b6 Whether to use http or https protocol. Default: http . If using https (strongly recommended), the following items should also be configured: ALLOWED_DOMAIN CA_ROOT CERT_CHAIN PRIVATE_KEY PYTHON_PATH \u00b6 The path to the Python executable (for running Python programs). Example: PYTHON_PATH=/usr/bin/python See also: NODE_PATH R_PATH RUN_TIMES SAS_PATH R_PATH \u00b6 The path to the R executable (for running R programs). Installation guides for R are available for Centos 7 , ubuntu and Debian . Example: R_PATH=/usr/bin/Rscript NODE_PATH PYTHON_PATH RUN_TIMES SAS_PATH RUN_TIMES \u00b6 A comma separated string that defines the available runtimes. Priority is given to the runtime that comes first in the string . Given a RUNTIME=js,sas,py : If _program=/some/program then SASjs Server will first look for program.js in the /some folder, then program.sas , and finally program.py . If _program=/some/program.sas then a SAS runtime will always be used. If _program=/some/program.r then an R runtime will be used (and so-on) Supported runtimes: js - JavaScript sas - SAS py - Python r - R Default: sas,js,py Example: RUN_TIMES=js,sas,py SAS_OPTIONS \u00b6 Windows only. See: https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/hostwin/p0drw76qo0gig2n1kcoliekh605k.htm#p09y7hx0grw1gin1giuvrjyx61m6 Example: SAS_OPTIONS= -NOXCMD SAS_PATH \u00b6 The full path to the SAS executable (sas.exe / sas.sh). It is highly recommended to provide an instance with UTF-8 encoding, for the following reasons: SASjs Adapter compatibility Broad language support Viya compatibility To force UTF-8 encoding, update the appropriate sasv9.cfg file with the following option: -ENCODING UTF-8 Example: SAS_PATH=/path/to/sas/executable.exe See also: NODE_PATH PYTHON_PATH RUN_TIMES SASJS_ROOT \u00b6 If omitted, this will be the SASjs Server installation directory. The location is used for SAS WORK, staged files, DRIVE, configuration etc Example: SASJS_ROOT=./sasjs_root SASV9_OPTIONS \u00b6 Unix only. See: https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/hostunx/p0wrdmqp8k0oyyn1xbx3bp3qy2wl.htm Example: SASV9_OPTIONS= -NOXCMD WHITELIST \u00b6 Space separated urls, eg: WHITELIST=http://localhost:3000 https://abc.com . See also: CORS","title":"Settings"},{"location":"settings/#settings","text":"All settings in SASjs server are made by means of environment variables. These can be set in the following places: Configured globally in /etc/environment file Export in terminal or shell script (export VAR=VALUE) Prepended in the command Enter in the .env file alongside the executable The usual / preferred method is to provide the variables in the .env file (which works on both Windows & Linux) as follows: In a server environment, it is highly recommended to protect this file with appropriate permissions (eg, to prevent changes being made by the shared identity under which the server is launched)","title":"Settings"},{"location":"settings/#environment-variables","text":"","title":"Environment Variables"},{"location":"settings/#admin_password_initial","text":"Defines the initial (temporary) password for the ADMIN_USERNAME , which is in place until the first login. Default is secretpassword . Example: ADMIN_PASSWORD_INITIAL=secretpassword","title":"ADMIN_PASSWORD_INITIAL"},{"location":"settings/#admin_password_reset","text":"This option can be used to force a reset of the password of the ADMIN_USERNAME . Default is NO. Possible options are YES and NO. If ADMIN_PASSWORD_RESET=YES then the ADMIN_USERNAME will be prompted to change the password from ADMIN_PASSWORD_INITIAL (default is secretpassword ) on next login. This will repeat on every server restart, unless the option is removed / set to NO. If the ADMIN_USERNAME is an existing, non-admin user then the password will NOT be reset (only works for admins). If the ADMIN_USERNAME uses an auth provider (eg LDAP) then again, this approach will not work. In this case, you can create a new admin user by setting a new ADMIN_USERNAME. Example: ADMIN_PASSWORD_RESET=NO","title":"ADMIN_PASSWORD_RESET"},{"location":"settings/#admin_username","text":"Used to define the name of the admin user on server startup. The default value is secretuser . If the user does not exist, it is created (eg during restarts). Example: ADMIN_USERNAME=secretuser","title":"ADMIN_USERNAME"},{"location":"settings/#auth_providers","text":"Used to list the desired Authentication providers (space separated). Currently only LDAP ( ldap ) is supported, but we plan to allow other providers such as Viya, Okta, OpenID, and LNURL-auth. Example: AUTH_PROVIDERS=ldap","title":"AUTH_PROVIDERS"},{"location":"settings/#allowed_domain","text":"Prevent authentication from other domains by listing the primary domain here. This will reject cookies arriving from any other domain. Used only when MODE=server , and only relevant for SASjs Studio / SASjs Logon. Example: ALLOWED_DOMAIN=sas.company.com For API use by different servers / domains, see CORS and WHITELIST settings.","title":"ALLOWED_DOMAIN"},{"location":"settings/#cert_chain","text":"Necessary when PROTOCOL=https Example: CERT_CHAIN=localhost.crt See also: PROTOCOL CA_ROOT PRIVATE_KEY Developer notes: processed internally as cert: option which has this description: Cert chains in PEM format. One cert chain should be provided per private key. Each cert chain should consist of the PEM formatted certificate for a provided private key, followed by the PEM formatted intermediate certificates (if any), in order, and not including the root CA (the root CA must be pre-known to the peer, see ca). When providing multiple cert chains, they do not have to be in the same order as their private keys in key. If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail.","title":"CERT_CHAIN"},{"location":"settings/#ca_root","text":"Necessary when PROTOCOL=https AND the server uses a self-signed certificate. Example: CA_ROOT=fullchain.pem See also: PROTOCOL CA_ROOT PRIVATE_KEY Developer notes: processed internally as ca: option which has this description: Optionally override the trusted CA certificates. Default is to trust the well-known CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are explicitly specified using this option. The value can be a string or Buffer, or an Array of strings and/or Buffers. Any string or Buffer can contain multiple PEM CAs concatenated together. The peer's certificate must be chainable to a CA trusted by the server for the connection to be authenticated. When using certificates that are not chainable to a well-known CA, the certificate's CA must be explicitly specified as a trusted or the connection will fail to authenticate. If the peer uses a certificate that doesn't match or chain to one of the default CAs, use the ca option to provide a CA certificate that the peer's certificate can match or chain to. For self-signed certificates, the certificate is its own CA, and must be provided. For PEM encoded certificates, supported types are \"TRUSTED CERTIFICATE\", \"X509 CERTIFICATE\", and \"CERTIFICATE\". See also tls.rootCertificates.","title":"CA_ROOT"},{"location":"settings/#cors","text":"Options: [disable|enable] Default: disable for server & enable for desktop If enabled, it is also necessary to configure the WHITELIST of additional server(s).","title":"CORS"},{"location":"settings/#db_connect","text":"In server mode it is necessary to use a database to store a number of attributes, such as: Users & Groups (if not using LDAP or other authentication source) Clients / Secrets (to enable REST API connections) Private keys (to spawn client ids, session tokens etc) Permissions (which users / groups are authorised to access which resources) This value contains the Connection string for the DB instance. Example: DB_CONNECT=mongodb+srv://<DB_USERNAME>:<DB_PASSWORD>@<CLUSTER>/<DB_NAME>?retryWrites=true&w=majority See also: DB_TYPE","title":"DB_CONNECT"},{"location":"settings/#db_type","text":"Specify the type of database. When DB_TYPE=cosmos_mongodb the connection is made using compatibility mode . Options: [mongodb|cosmos_mongodb] Default: mongodb","title":"DB_TYPE"},{"location":"settings/#drive_location","text":"This setting is useful if you are running multiple instances of SASjs Server and would like to re-use the same Drive folder, Macros, Packages, and appStream config. The DRIVE_LOCATION can be shared across instances, but the SASJS_ROOT can't - as it will cause conflicts with sessions / uploads etc. If using this feature, be aware that the appStreamConfig.json is loaded on server startup - therefore if you are deploying a new app (or modifying app metadata attributes, such as the logo), the other instances will need to be restarted to view them in the portal. If this is problematic for your project, please raise an issue . See also: LOG_LOCATION SASJS_ROOT","title":"DRIVE_LOCATION"},{"location":"settings/#helmet_coep","text":"HELMET Cross Origin Embedder Policy. Sets the Cross-Origin-Embedder-Policy header to require-corp when true Options: [true|false] Default: true Docs: https://helmetjs.github.io/#reference ( crossOriginEmbedderPolicy )","title":"HELMET_COEP"},{"location":"settings/#helmet_csp_config_path","text":"HELMET Content Security Policy Path to a json file containing HELMET contentSecurityPolicy directives Docs: https://helmetjs.github.io/#reference Example config: { \"img-src\": [\"'self'\", \"data:\"], \"script-src\": [\"'self'\", \"'unsafe-inline'\"], \"script-src-attr\": [\"'self'\", \"'unsafe-inline'\"] } Example: HELMET_CSP_CONFIG_PATH=./csp.config.json","title":"HELMET_CSP_CONFIG_PATH"},{"location":"settings/#ldap_url","text":"The URL of the LDAP directory server. Example: LDAP_URL= ldaps://LDAP_SERVER_URL:PORT","title":"LDAP_URL"},{"location":"settings/#ldap_bind_dn","text":"Example: LDAP_BIND_DN=cn=admin,ou=system,dc=companyname","title":"LDAP_BIND_DN"},{"location":"settings/#ldap_bind_password","text":"All LDAP queries have to be authenticated with this secret and the LDAP_USERS_BASE_DN Example: LDAP_BIND_PASSWORD = <password>","title":"LDAP_BIND_PASSWORD"},{"location":"settings/#ldap_users_base_dn","text":"LDAP_USERS_BASE_DN = ou=users,dc=companyname","title":"LDAP_USERS_BASE_DN"},{"location":"settings/#ldap_groups_base_dn","text":"LDAP_GROUPS_BASE_DN = ou=groups,dc=companyname","title":"LDAP_GROUPS_BASE_DN"},{"location":"settings/#log_format_morgan","text":"These setting determines the level of logging produced by SASjs server. More details on this can be found in the Morgan documentation here: https://www.npmjs.com/package/morgan#predefined-formats Options: [ combined | common | dev | short | tiny ] Default: common","title":"LOG_FORMAT_MORGAN"},{"location":"settings/#log_location","text":"Location in which to write server logs (one file per day). If not provided, logs are written in a /logs subfolder of the SASJS_ROOT location. Can be a full path, else relative to the directory in which the server instance was launched. More information on the behaviour (eg log rotation) is available in the underlying package ( rotating-file-stream ). Example: LOG_LOCATION=./sasjs_root/logs","title":"LOG_LOCATION"},{"location":"settings/#mock_servertype","text":"Used internally for CLI / Adapter testing - set to SAS9 or SASVIYA when launching to enable responses in the format of alternative platforms. These mocks are not functional, and have no use outside of development / testing purposes. Default: SASJS","title":"MOCK_SERVERTYPE"},{"location":"settings/#mode","text":"Whether to launch the server in desktop (single user / workstation) or server mode (multi-user). For server mode, a Mongo DB connection string must be provided in the DB_CONNECT variable. Default: desktop","title":"MODE"},{"location":"settings/#node_path","text":"The path to the NodeJS executable (for running JavaScript programs). Example: NODE_PATH=~/.nvm/versions/node/v16.14.0/bin/node See also: PYTHON_PATH RUN_TIMES SAS_PATH","title":"NODE_PATH"},{"location":"settings/#port","text":"The port on which to serve. Default: 5000 Binding processes to ports in the lower ranges (eg 80, 443) requires elevated privileges. To avoid running SASjs Server under a privileged account, you can bind the port to an executable - eg: setcap 'cap_net_bind_service=+ep' /home/sasjssrv/api-linux If the executable is updated (eg downloading a new version) you will need to run this command again.","title":"PORT"},{"location":"settings/#private_key","text":"Necessary when PROTOCOL=https Example: PRIVATE_KEY=localhost.key See also: PROTOCOL CA_ROOT CERT_CHAIN Developer notes: processed internally as key: option which has this description: Private keys in PEM format. PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.passphrase. Multiple keys using different algorithms can be provided either as an array of unencrypted key strings or buffers, or an array of objects in the form {pem: [, passphrase: ]}. The object form can only occur in an array. object.passphrase is optional. Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase if it is not.","title":"PRIVATE_KEY"},{"location":"settings/#protocol","text":"Whether to use http or https protocol. Default: http . If using https (strongly recommended), the following items should also be configured: ALLOWED_DOMAIN CA_ROOT CERT_CHAIN PRIVATE_KEY","title":"PROTOCOL"},{"location":"settings/#python_path","text":"The path to the Python executable (for running Python programs). Example: PYTHON_PATH=/usr/bin/python See also: NODE_PATH R_PATH RUN_TIMES SAS_PATH","title":"PYTHON_PATH"},{"location":"settings/#r_path","text":"The path to the R executable (for running R programs). Installation guides for R are available for Centos 7 , ubuntu and Debian . Example: R_PATH=/usr/bin/Rscript NODE_PATH PYTHON_PATH RUN_TIMES SAS_PATH","title":"R_PATH"},{"location":"settings/#run_times","text":"A comma separated string that defines the available runtimes. Priority is given to the runtime that comes first in the string . Given a RUNTIME=js,sas,py : If _program=/some/program then SASjs Server will first look for program.js in the /some folder, then program.sas , and finally program.py . If _program=/some/program.sas then a SAS runtime will always be used. If _program=/some/program.r then an R runtime will be used (and so-on) Supported runtimes: js - JavaScript sas - SAS py - Python r - R Default: sas,js,py Example: RUN_TIMES=js,sas,py","title":"RUN_TIMES"},{"location":"settings/#sas_options","text":"Windows only. See: https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/hostwin/p0drw76qo0gig2n1kcoliekh605k.htm#p09y7hx0grw1gin1giuvrjyx61m6 Example: SAS_OPTIONS= -NOXCMD","title":"SAS_OPTIONS"},{"location":"settings/#sas_path","text":"The full path to the SAS executable (sas.exe / sas.sh). It is highly recommended to provide an instance with UTF-8 encoding, for the following reasons: SASjs Adapter compatibility Broad language support Viya compatibility To force UTF-8 encoding, update the appropriate sasv9.cfg file with the following option: -ENCODING UTF-8 Example: SAS_PATH=/path/to/sas/executable.exe See also: NODE_PATH PYTHON_PATH RUN_TIMES","title":"SAS_PATH"},{"location":"settings/#sasjs_root","text":"If omitted, this will be the SASjs Server installation directory. The location is used for SAS WORK, staged files, DRIVE, configuration etc Example: SASJS_ROOT=./sasjs_root","title":"SASJS_ROOT"},{"location":"settings/#sasv9_options","text":"Unix only. See: https://documentation.sas.com/doc/en/pgmsascdc/9.4_3.5/hostunx/p0wrdmqp8k0oyyn1xbx3bp3qy2wl.htm Example: SASV9_OPTIONS= -NOXCMD","title":"SASV9_OPTIONS"},{"location":"settings/#whitelist","text":"Space separated urls, eg: WHITELIST=http://localhost:3000 https://abc.com . See also: CORS","title":"WHITELIST"},{"location":"storedprograms/","text":"Stored Programs \u00b6 Stored Programs may be written in SAS, Python, R, or JavaScript and are saved to SASjs Drive. When the /SASjsApi/stp/execute endpoint is called with a _PROGRAM URL parameter (pointing to the logical program location), a \"Stored Program\" is prepared and executed in a SAS/JS/PYTHON/R session according to the file extension. For the usual case where the _program variable does NOT contain an extension (eg /some/stored/program ) then by default, SASjs Server will attempt to find \"program.sas\" in the /some/stored folder. To change this default, see the RUN_TIMES settings. When Stored Programs are executed, some pre-code is injected to make available various inputs, such as: Input Macro Variables Input Files Utility Macros / Functions The implementation varies depending on whether it is running as a SAS, JS, Python or R session. If you are calling your Stored Programs from a web application, it is recommended to review the sasjs/adapter (designed to work with Stored Programs) and associated seed apps . You might also want to review the Data Controller source as an example of a relatively large, commercial application built on SASjs. Special Variables \u00b6 The following variables are \"special\": _PROGRAM \u00b6 This is a required input, and will point to the Stored Program location in SASjs Drive. The extension may be omitted, subject to the behaviour in the RUN_TIMES setting. _DEBUG \u00b6 Setting this to 131 or greater will result in the log being returned. The log will have the following UUID, which can be used as a seperator: SASJS_LOGS_SEPARATOR_163ee17b6ff24f028928972d80a26784 Setting _DEBUG also results in the creation of a Content-Type header of text/plain . SAS Programs \u00b6 Input Variables \u00b6 Any URL parameters (eg &name1=value1&something=else ) are attached as macro variables eg as follows: %let name1=value1; %let something= else ; A number of \"fixed\" variables are also added at the start of the program - you can see the code that generates these in the repo, here . If _DEBUG is set then options mprint; will also be automatically added to the start of the Stored Program. Input Files \u00b6 Any files attached to a request will be saved in the session folder and the following variables will be dynamically added to the SAS program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_FILEREF1 - An 8 letter code, starting with an underscore and finishing with 7 random alphanumeric characters _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend We will also create the fileref(s) using the filename statement. To illustrate with an example - we are uploading two files, F1 and F2. The following SAS code will be generated, and inserted at the beginning of the executed program: /* request files */ filename _SJS0001 \"/some/temp/location/file1\" ; filename _SJS0002 \"/some/temp/location/file2\" ; %let _WEBIN_FILE_COUNT= 2 ; %let _WEBIN_FILENAME1=myfile . csv; %let _WEBIN_FILENAME2=myotherfile . txt; %let _WEBIN_FILEREF1=_SJS0001; %let _WEBIN_FILEREF2=_SJS0002; %let _WEBIN_NAME1=F1; %let _WEBIN_NAME2=F2; If there are no files uploaded, only the following code will be generated: /* request files */ %let _WEBIN_FILE_COUNT= 0 ; Output \u00b6 Any response data should be written to the _webout fileref (which is pre-assigned in the session). The corresponding header records (content type etc) can be written using the mfs_httpheader macro. Additional SASjs Server specific macros are also available. The response (content and header) will vary depending on the _debug setting. JS Programs \u00b6 The use of JS \"programs\" as your backend is highly beneficial for the following use cases: You would like to test your application in a non SAS environment (such as a CI/CD pipeline or developer machine) You would like to make use of JS packages in your backend SAS applications You would like to provide backup services in the case that SAS is down (eg licence expiry) Any console.log() statements written by your JavaScript will be returned in the response \"log\" (identically to SAS). If your Job / Service / Test depends on any third party libraries / packages, then you need to bundle that service before deploying it to sasjs server. You can choose any bundler for this process. One possible option could be webpack . If you choose webpack then you can use it like this: npx webpack --mode none --target node --entry <path-of-file-to-bundle/build> --output-path <path-of-output-folder> --output-filename <name-of-output-file> For instance if you have a mock service at path sasjs/services/common/appinit.js and you want to build and make it ready for deployment, you can run the following in the terminal: npx webpack --mode none --target node --entry ./sasjs/services/common/appinit.js --output-path sasjsbuild/services/common --output-filename appinit.js Repeat this for any other JS Stored Programs as needed. Finally, run sasjs build to create the deployment pack, and sasjs deploy to deploy. Input Variables \u00b6 Any URL parameters (eg &name1=value1&something=else ) are attached as JS variables eg as follows: const name1 = 'value1' const something = 'else' A number of \"fixed\" variables are also added at the start of the program, eg: let _webout = '' ; weboutPath = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/webout.txt' ; const _sasjs_tokenfile = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; const _sasjs_username = 'allan' ; const _sasjs_userid = '6' ; const _sasjs_displayname = 'Allan Bowe' ; const _metaperson = _sasjs_displayname ; const _metauser = _sasjs_username ; const sasjsprocessmode = 'Stored Program' ; Input Files \u00b6 Any files attached to a request will be saved in the session folder and the following variables will be dynamically added to the JS program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_FILEREF1 - This will contain the actual file object _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files, F1 and F2. The following JS code will be generated, and inserted at the beginning of the executed program: const _WEBIN_FILEREF1 = fs . readFileSync ( '/path/to/file1' ) const _WEBIN_FILEREF2 = fs . readFileSync ( '/path/to/file2' ) const _WEBIN_FILENAME1 = 'F1' const _WEBIN_FILENAME2 = 'F2' const _WEBIN_NAME1 = 'FormRef1' const _WEBIN_NAME2 = 'FormRef2' const _WEBIN_FILE_COUNT = 2 If there are no files uploaded, only the following code will be generated: const _WEBIN_FILE_COUNT = 0 Output \u00b6 The following variables are \"special\": _SASJS_WEBOUT_HEADERS \u00b6 This (string) variable points to the location of a text file where header records (such as Content-type: application/zip ) can be written. Sample code that could be used to perform such an operation might look like: fs.writeFile(_SASJS_WEBOUT_HEADERS, 'Content-type: application/zip', function (err) { if (err) throw err; }) So long as Content-type: application/zip is the last entry in the file, it will be applied as the content-type in the Response Header. _webout \u00b6 Any content added to this variable will be stringified and automatically returned to the browser by SASjs Server. The variable can be used to hold binary, or textual content. Whatever is contained within this variable, is what will be returned in the Response Body. If it is not HTML, then it may be necessary also to set the Request Headers using the temporary file in the _SASJS_WEBOUT_HEADERS variable above. Python Programs \u00b6 The use of Python \"programs\" as your backend is highly beneficial for the following use cases: You would like to test your application in a non SAS environment (such as a CI/CD pipeline or developer machine) You would like to make use of Python packages in your SAS applications You would like to provide backup services in case SAS is unavailable Any content written to sys.stdout or sys.stderr will be returned in the response \"log\" (identically to SAS). Input Variables \u00b6 Any URL parameters (eg &name1=value1&something=else ) are attached as Python variables in uppercase, eg as follows: NAME1 = 'value1' SOMETHING = 'else' A number of \"fixed\" variables are also added at the start of the program, eg as follows: _SASJS_TOKENFILE = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; _SASJS_USERNAME = 'allan' ; _SASJS_USERID = '6' ; _SASJS_DISPLAYNAME = 'Allan Bowe' ; _METAPERSON = _SASJS_DISPLAYNAME ; _METAUSER = _SASJS_USERNAME ; SASJSPROCESSMODE = 'Stored Program' ; Input Files \u00b6 Any files attached to a request will be saved in the session folder . The session folder (with the input files) will also be the current folder, eg os.chdir(\"/path/to/session/folder\") . When input files exist, the following variables will also be dynamically added to the Python program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files to a Python Stored Program, namely f1.txt and f2.xls. The following Python code will be generated, and inserted at the beginning of the executed program: _WEBIN_FILENAME1 = 'f1.txt' _WEBIN_FILENAME2 = 'f2.xls' _WEBIN_NAME1 = 'FormRef1' _WEBIN_NAME2 = 'FormRef2' _WEBIN_FILE_COUNT = 2 If there are no files uploaded, only the following code will be generated: _WEBIN_FILE_COUNT = 0 Note that there are no _WEBIN_FILEREF variables created - in Python it is necessary to know the type of file (eg binary / text) before it can be ingested with the open() function, eg open(_WEBIN_FILENAME1,\"rt\") or open(_WEBIN_FILENAME2,\"rb\") . Therefore it is left as an exercise for the developer to ingest as appropriate. Output \u00b6 The following variables are \"special\": _WEBOUT \u00b6 This variable points to a text file in the session folder (eg _WEBOUT=\"/path/to/session/folder/webout.txt\" ). All content written to _WEBOUT is streamed in the STP API call result. Example code: f = open ( _WEBOUT , 'w' ) f . write ( '{\"hello\":\"world\"}' ) HEADERSPATH \u00b6 This variable points to a text file where header records (such as Content-type: application/zip ) can be written, eg HEADERSPATH=\"/path/to/session/folder/headers.txt\" ). To return data to the client, just write it to the _WEBOUT file. It will then be returned to the browser / client application. Be sure to set the Content-Type in the HEADERSPATH file if it is anything other than JSON. R Programs \u00b6 Stored Programs may also run using the language of R. Any content written to .ROut will be returned in the response \"log\" (identically to SAS). As R does not support the underscore ( _ ) as the first character in a variable name, the automatic variables are preceded with a period ( . ) instead. Input Variables \u00b6 Any URL parameters (eg &name1=value1&something=else ) are attached as R variables in uppercase, eg as follows: NAME1 <- 'value1' SOMETHING <- 'else' A number of \"fixed\" variables are also added at the start of the program, eg as follows: ._SASJS_TOKENFILE <- '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; ._SASJS_USERNAME <- 'allan' ; ._SASJS_USERID <- '6' ; ._SASJS_DISPLAYNAME <- 'Allan Bowe' ; ._METAPERSON <- ._SASJS_DISPLAYNAME ; ._METAUSER <- ._SASJS_USERNAME ; SASJSPROCESSMODE <- 'Stored Program' ; Input Files \u00b6 Any files attached to a request will be saved in the session folder . The session folder (with the input files) will also be the current folder, eg setwd(\"/path/to/session/folder\") . When input files exist, the following variables will also be dynamically added to the R program: ._WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. ._WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend ._WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files to an R Stored Program, namely f1.txt and f2.xls. The following R code will be generated, and inserted at the beginning of the executed program: ._WEBIN_FILENAME1 <- 'f1.txt' ._WEBIN_FILENAME2 <- 'f2.xls' ._WEBIN_NAME1 <- 'FormRef1' ._WEBIN_NAME1 <- 'FormRef2' ._WEBIN_FILE_COUNT <- 2 If there are no files uploaded, only the following code will be generated: ._WEBIN_FILE_COUNT <- 0 Note that there are no ._WEBIN_FILEREF variables created - in R it is necessary to know the type of file (eg binary / text) before it can be ingested, eg read.delim(._WEBIN_FILENAME1, header = FALSE) or read.delim2(._WEBIN_FILENAME2, header = FALSE) . Therefore it is left as an exercise for the developer to ingest as appropriate. Output \u00b6 The following variables are \"special\": ._WEBOUT \u00b6 This variable points to a text file in the session folder (eg ._WEBOUT <- \"/path/to/session/folder/webout.txt\" ). All content written to ._WEBOUT is streamed in the STP API call result. Example code: cat ( '{\"hello\":\"world\"}' , file = ._WEBOUT ) HEADERSPATH \u00b6 This variable points to a text file where header records (such as Content-type: application/zip ) can be written, eg HEADERSPATH <- \"/path/to/session/folder/headers.txt\" ). To return data to the client, just write it to the ._WEBOUT file. It will then be returned to the browser / client application. Be sure to set the Content-Type in the HEADERSPATH file if it is anything other than JSON.","title":"Stored Programs"},{"location":"storedprograms/#stored-programs","text":"Stored Programs may be written in SAS, Python, R, or JavaScript and are saved to SASjs Drive. When the /SASjsApi/stp/execute endpoint is called with a _PROGRAM URL parameter (pointing to the logical program location), a \"Stored Program\" is prepared and executed in a SAS/JS/PYTHON/R session according to the file extension. For the usual case where the _program variable does NOT contain an extension (eg /some/stored/program ) then by default, SASjs Server will attempt to find \"program.sas\" in the /some/stored folder. To change this default, see the RUN_TIMES settings. When Stored Programs are executed, some pre-code is injected to make available various inputs, such as: Input Macro Variables Input Files Utility Macros / Functions The implementation varies depending on whether it is running as a SAS, JS, Python or R session. If you are calling your Stored Programs from a web application, it is recommended to review the sasjs/adapter (designed to work with Stored Programs) and associated seed apps . You might also want to review the Data Controller source as an example of a relatively large, commercial application built on SASjs.","title":"Stored Programs"},{"location":"storedprograms/#special-variables","text":"The following variables are \"special\":","title":"Special Variables"},{"location":"storedprograms/#_program","text":"This is a required input, and will point to the Stored Program location in SASjs Drive. The extension may be omitted, subject to the behaviour in the RUN_TIMES setting.","title":"_PROGRAM"},{"location":"storedprograms/#_debug","text":"Setting this to 131 or greater will result in the log being returned. The log will have the following UUID, which can be used as a seperator: SASJS_LOGS_SEPARATOR_163ee17b6ff24f028928972d80a26784 Setting _DEBUG also results in the creation of a Content-Type header of text/plain .","title":"_DEBUG"},{"location":"storedprograms/#sas-programs","text":"","title":"SAS Programs"},{"location":"storedprograms/#input-variables","text":"Any URL parameters (eg &name1=value1&something=else ) are attached as macro variables eg as follows: %let name1=value1; %let something= else ; A number of \"fixed\" variables are also added at the start of the program - you can see the code that generates these in the repo, here . If _DEBUG is set then options mprint; will also be automatically added to the start of the Stored Program.","title":"Input Variables"},{"location":"storedprograms/#input-files","text":"Any files attached to a request will be saved in the session folder and the following variables will be dynamically added to the SAS program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_FILEREF1 - An 8 letter code, starting with an underscore and finishing with 7 random alphanumeric characters _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend We will also create the fileref(s) using the filename statement. To illustrate with an example - we are uploading two files, F1 and F2. The following SAS code will be generated, and inserted at the beginning of the executed program: /* request files */ filename _SJS0001 \"/some/temp/location/file1\" ; filename _SJS0002 \"/some/temp/location/file2\" ; %let _WEBIN_FILE_COUNT= 2 ; %let _WEBIN_FILENAME1=myfile . csv; %let _WEBIN_FILENAME2=myotherfile . txt; %let _WEBIN_FILEREF1=_SJS0001; %let _WEBIN_FILEREF2=_SJS0002; %let _WEBIN_NAME1=F1; %let _WEBIN_NAME2=F2; If there are no files uploaded, only the following code will be generated: /* request files */ %let _WEBIN_FILE_COUNT= 0 ;","title":"Input Files"},{"location":"storedprograms/#output","text":"Any response data should be written to the _webout fileref (which is pre-assigned in the session). The corresponding header records (content type etc) can be written using the mfs_httpheader macro. Additional SASjs Server specific macros are also available. The response (content and header) will vary depending on the _debug setting.","title":"Output"},{"location":"storedprograms/#js-programs","text":"The use of JS \"programs\" as your backend is highly beneficial for the following use cases: You would like to test your application in a non SAS environment (such as a CI/CD pipeline or developer machine) You would like to make use of JS packages in your backend SAS applications You would like to provide backup services in the case that SAS is down (eg licence expiry) Any console.log() statements written by your JavaScript will be returned in the response \"log\" (identically to SAS). If your Job / Service / Test depends on any third party libraries / packages, then you need to bundle that service before deploying it to sasjs server. You can choose any bundler for this process. One possible option could be webpack . If you choose webpack then you can use it like this: npx webpack --mode none --target node --entry <path-of-file-to-bundle/build> --output-path <path-of-output-folder> --output-filename <name-of-output-file> For instance if you have a mock service at path sasjs/services/common/appinit.js and you want to build and make it ready for deployment, you can run the following in the terminal: npx webpack --mode none --target node --entry ./sasjs/services/common/appinit.js --output-path sasjsbuild/services/common --output-filename appinit.js Repeat this for any other JS Stored Programs as needed. Finally, run sasjs build to create the deployment pack, and sasjs deploy to deploy.","title":"JS Programs"},{"location":"storedprograms/#input-variables_1","text":"Any URL parameters (eg &name1=value1&something=else ) are attached as JS variables eg as follows: const name1 = 'value1' const something = 'else' A number of \"fixed\" variables are also added at the start of the program, eg: let _webout = '' ; weboutPath = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/webout.txt' ; const _sasjs_tokenfile = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; const _sasjs_username = 'allan' ; const _sasjs_userid = '6' ; const _sasjs_displayname = 'Allan Bowe' ; const _metaperson = _sasjs_displayname ; const _metauser = _sasjs_username ; const sasjsprocessmode = 'Stored Program' ;","title":"Input Variables"},{"location":"storedprograms/#input-files_1","text":"Any files attached to a request will be saved in the session folder and the following variables will be dynamically added to the JS program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_FILEREF1 - This will contain the actual file object _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files, F1 and F2. The following JS code will be generated, and inserted at the beginning of the executed program: const _WEBIN_FILEREF1 = fs . readFileSync ( '/path/to/file1' ) const _WEBIN_FILEREF2 = fs . readFileSync ( '/path/to/file2' ) const _WEBIN_FILENAME1 = 'F1' const _WEBIN_FILENAME2 = 'F2' const _WEBIN_NAME1 = 'FormRef1' const _WEBIN_NAME2 = 'FormRef2' const _WEBIN_FILE_COUNT = 2 If there are no files uploaded, only the following code will be generated: const _WEBIN_FILE_COUNT = 0","title":"Input Files"},{"location":"storedprograms/#output_1","text":"The following variables are \"special\":","title":"Output"},{"location":"storedprograms/#_sasjs_webout_headers","text":"This (string) variable points to the location of a text file where header records (such as Content-type: application/zip ) can be written. Sample code that could be used to perform such an operation might look like: fs.writeFile(_SASJS_WEBOUT_HEADERS, 'Content-type: application/zip', function (err) { if (err) throw err; }) So long as Content-type: application/zip is the last entry in the file, it will be applied as the content-type in the Response Header.","title":"_SASJS_WEBOUT_HEADERS"},{"location":"storedprograms/#_webout","text":"Any content added to this variable will be stringified and automatically returned to the browser by SASjs Server. The variable can be used to hold binary, or textual content. Whatever is contained within this variable, is what will be returned in the Response Body. If it is not HTML, then it may be necessary also to set the Request Headers using the temporary file in the _SASJS_WEBOUT_HEADERS variable above.","title":"_webout"},{"location":"storedprograms/#python-programs","text":"The use of Python \"programs\" as your backend is highly beneficial for the following use cases: You would like to test your application in a non SAS environment (such as a CI/CD pipeline or developer machine) You would like to make use of Python packages in your SAS applications You would like to provide backup services in case SAS is unavailable Any content written to sys.stdout or sys.stderr will be returned in the response \"log\" (identically to SAS).","title":"Python Programs"},{"location":"storedprograms/#input-variables_2","text":"Any URL parameters (eg &name1=value1&something=else ) are attached as Python variables in uppercase, eg as follows: NAME1 = 'value1' SOMETHING = 'else' A number of \"fixed\" variables are also added at the start of the program, eg as follows: _SASJS_TOKENFILE = '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; _SASJS_USERNAME = 'allan' ; _SASJS_USERID = '6' ; _SASJS_DISPLAYNAME = 'Allan Bowe' ; _METAPERSON = _SASJS_DISPLAYNAME ; _METAUSER = _SASJS_USERNAME ; SASJSPROCESSMODE = 'Stored Program' ;","title":"Input Variables"},{"location":"storedprograms/#input-files_2","text":"Any files attached to a request will be saved in the session folder . The session folder (with the input files) will also be the current folder, eg os.chdir(\"/path/to/session/folder\") . When input files exist, the following variables will also be dynamically added to the Python program: _WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. _WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend _WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files to a Python Stored Program, namely f1.txt and f2.xls. The following Python code will be generated, and inserted at the beginning of the executed program: _WEBIN_FILENAME1 = 'f1.txt' _WEBIN_FILENAME2 = 'f2.xls' _WEBIN_NAME1 = 'FormRef1' _WEBIN_NAME2 = 'FormRef2' _WEBIN_FILE_COUNT = 2 If there are no files uploaded, only the following code will be generated: _WEBIN_FILE_COUNT = 0 Note that there are no _WEBIN_FILEREF variables created - in Python it is necessary to know the type of file (eg binary / text) before it can be ingested with the open() function, eg open(_WEBIN_FILENAME1,\"rt\") or open(_WEBIN_FILENAME2,\"rb\") . Therefore it is left as an exercise for the developer to ingest as appropriate.","title":"Input Files"},{"location":"storedprograms/#output_2","text":"The following variables are \"special\":","title":"Output"},{"location":"storedprograms/#_webout_1","text":"This variable points to a text file in the session folder (eg _WEBOUT=\"/path/to/session/folder/webout.txt\" ). All content written to _WEBOUT is streamed in the STP API call result. Example code: f = open ( _WEBOUT , 'w' ) f . write ( '{\"hello\":\"world\"}' )","title":"_WEBOUT"},{"location":"storedprograms/#headerspath","text":"This variable points to a text file where header records (such as Content-type: application/zip ) can be written, eg HEADERSPATH=\"/path/to/session/folder/headers.txt\" ). To return data to the client, just write it to the _WEBOUT file. It will then be returned to the browser / client application. Be sure to set the Content-Type in the HEADERSPATH file if it is anything other than JSON.","title":"HEADERSPATH"},{"location":"storedprograms/#r-programs","text":"Stored Programs may also run using the language of R. Any content written to .ROut will be returned in the response \"log\" (identically to SAS). As R does not support the underscore ( _ ) as the first character in a variable name, the automatic variables are preceded with a period ( . ) instead.","title":"R Programs"},{"location":"storedprograms/#input-variables_3","text":"Any URL parameters (eg &name1=value1&something=else ) are attached as R variables in uppercase, eg as follows: NAME1 <- 'value1' SOMETHING <- 'else' A number of \"fixed\" variables are also added at the start of the program, eg as follows: ._SASJS_TOKENFILE <- '/home/sasjssrv/sasjs_root/sessions/20220808081136-29012-1659946296436/reqHeaders.txt' ; ._SASJS_USERNAME <- 'allan' ; ._SASJS_USERID <- '6' ; ._SASJS_DISPLAYNAME <- 'Allan Bowe' ; ._METAPERSON <- ._SASJS_DISPLAYNAME ; ._METAUSER <- ._SASJS_USERNAME ; SASJSPROCESSMODE <- 'Stored Program' ;","title":"Input Variables"},{"location":"storedprograms/#input-files_3","text":"Any files attached to a request will be saved in the session folder . The session folder (with the input files) will also be the current folder, eg setwd(\"/path/to/session/folder\") . When input files exist, the following variables will also be dynamically added to the R program: ._WEBIN_FILE_COUNT - contains an integer, from 0 to the number of files to being provided. This variable is always created. ._WEBIN_FILENAME1 - the value that was specified in the FILENAME attribute by the frontend ._WEBIN_NAME1 - the value that was specified in the NAME attribute by the frontend To illustrate with an example - we are uploading two files to an R Stored Program, namely f1.txt and f2.xls. The following R code will be generated, and inserted at the beginning of the executed program: ._WEBIN_FILENAME1 <- 'f1.txt' ._WEBIN_FILENAME2 <- 'f2.xls' ._WEBIN_NAME1 <- 'FormRef1' ._WEBIN_NAME1 <- 'FormRef2' ._WEBIN_FILE_COUNT <- 2 If there are no files uploaded, only the following code will be generated: ._WEBIN_FILE_COUNT <- 0 Note that there are no ._WEBIN_FILEREF variables created - in R it is necessary to know the type of file (eg binary / text) before it can be ingested, eg read.delim(._WEBIN_FILENAME1, header = FALSE) or read.delim2(._WEBIN_FILENAME2, header = FALSE) . Therefore it is left as an exercise for the developer to ingest as appropriate.","title":"Input Files"},{"location":"storedprograms/#output_3","text":"The following variables are \"special\":","title":"Output"},{"location":"storedprograms/#_webout_2","text":"This variable points to a text file in the session folder (eg ._WEBOUT <- \"/path/to/session/folder/webout.txt\" ). All content written to ._WEBOUT is streamed in the STP API call result. Example code: cat ( '{\"hello\":\"world\"}' , file = ._WEBOUT )","title":"._WEBOUT"},{"location":"storedprograms/#headerspath_1","text":"This variable points to a text file where header records (such as Content-type: application/zip ) can be written, eg HEADERSPATH <- \"/path/to/session/folder/headers.txt\" ). To return data to the client, just write it to the ._WEBOUT file. It will then be returned to the browser / client application. Be sure to set the Content-Type in the HEADERSPATH file if it is anything other than JSON.","title":"HEADERSPATH"},{"location":"studio/","text":"SASjs Studio \u00b6 Run SAS or JS code in a single interface! Just select your preferred runtime from the dropdown next to the running man. It is possible to ctrl-click to run code, or to highlight and select the running man icon. Code is saved in local storage, so you don't lose your work if you close the browser tab. SAS specific \u00b6 The big difference between SASjs Studio and other SAS executors is that every execution is with a CLEAN session. Other than that, everything works as you would expect. The log is sent to the log window, and the WEBOUT page contains any content sent to the _webout fileref. JS specific \u00b6 When running JS code, any console.log() statements are sent to the log window, and any content saved in the _webout variable is sent to the webout page. Launch Mode \u00b6 When clicking the LAUNCH icon, a NEW window (or tab) is opened with the file location in the _program url param. For instance, if opening /Public/subfolder/someprog.sas then the url will be: /SASjsExecutor?_program=/Public/subfolder/someprog.sas .","title":"SASjs Studio"},{"location":"studio/#sasjs-studio","text":"Run SAS or JS code in a single interface! Just select your preferred runtime from the dropdown next to the running man. It is possible to ctrl-click to run code, or to highlight and select the running man icon. Code is saved in local storage, so you don't lose your work if you close the browser tab.","title":"SASjs Studio"},{"location":"studio/#sas-specific","text":"The big difference between SASjs Studio and other SAS executors is that every execution is with a CLEAN session. Other than that, everything works as you would expect. The log is sent to the log window, and the WEBOUT page contains any content sent to the _webout fileref.","title":"SAS specific"},{"location":"studio/#js-specific","text":"When running JS code, any console.log() statements are sent to the log window, and any content saved in the _webout variable is sent to the webout page.","title":"JS specific"},{"location":"studio/#launch-mode","text":"When clicking the LAUNCH icon, a NEW window (or tab) is opened with the file location in the _program url param. For instance, if opening /Public/subfolder/someprog.sas then the url will be: /SASjsExecutor?_program=/Public/subfolder/someprog.sas .","title":"Launch Mode"}]}